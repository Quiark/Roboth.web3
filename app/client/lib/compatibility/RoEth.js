/**
This is kind of a bridge between the eth / smart contract and the Meteor reactive-driven world
named RoEth for a lack of imagination

@module RoEth
*/

function RoEthCls() {
	this. RegistrarABI = [{"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"name","outputs":[{"name":"o_name","type":"bytes32"}],"type":"function"},{"constant":true,"inputs":[{"name":"_name","type":"bytes32"}],"name":"owner","outputs":[{"name":"","type":"address"}],"type":"function"},{"constant":true,"inputs":[{"name":"_name","type":"bytes32"}],"name":"content","outputs":[{"name":"","type":"bytes32"}],"type":"function"},{"constant":true,"inputs":[{"name":"_name","type":"bytes32"}],"name":"addr","outputs":[{"name":"","type":"address"}],"type":"function"},{"constant":false,"inputs":[{"name":"_name","type":"bytes32"}],"name":"reserve","outputs":[],"type":"function"},{"constant":true,"inputs":[{"name":"_name","type":"bytes32"}],"name":"subRegistrar","outputs":[{"name":"o_subRegistrar","type":"address"}],"type":"function"},{"constant":false,"inputs":[{"name":"_name","type":"bytes32"},{"name":"_newOwner","type":"address"}],"name":"transfer","outputs":[],"type":"function"},{"constant":false,"inputs":[{"name":"_name","type":"bytes32"},{"name":"_registrar","type":"address"}],"name":"setSubRegistrar","outputs":[],"type":"function"},{"constant":false,"inputs":[],"name":"Registrar","outputs":[],"type":"function"},{"constant":false,"inputs":[{"name":"_name","type":"bytes32"},{"name":"_a","type":"address"},{"name":"_primary","type":"bool"}],"name":"setAddress","outputs":[],"type":"function"},{"constant":false,"inputs":[{"name":"_name","type":"bytes32"},{"name":"_content","type":"bytes32"}],"name":"setContent","outputs":[],"type":"function"},{"constant":false,"inputs":[{"name":"_name","type":"bytes32"}],"name":"disown","outputs":[],"type":"function"},{"constant":true,"inputs":[{"name":"_name","type":"bytes32"}],"name":"register","outputs":[{"name":"","type":"address"}],"type":"function"},{"anonymous":false,"inputs":[{"indexed":true,"name":"name","type":"bytes32"}],"name":"Changed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"name","type":"bytes32"},{"indexed":true,"name":"addr","type":"address"}],"name":"PrimaryChanged","type":"event"}];
	this. RegistrarAddr = "0x7baae5f7546381f59710b922f55110d9f8704b1d";
	if (true) {
		// test-rpc env
		this.RegistrarAddr = '0x19eaa2d242cace5754f1dcc3cf94d7a692dd8de2';
	}

	this. RegistrarAPI = web3.eth.contract(this.RegistrarABI);
	this. Registrar = this.RegistrarAPI.at(this.RegistrarAddr);

	// FIX for registrar using bytes instead of string
	var old_name = this.Registrar.name;
	this.Registrar.name = function(t, addr) {
		var res = old_name.apply([t, addr]);
		return web3.toAscii(res);
	}

	// comes from RobothABI.js, generated by a script
	this. RobothABI = window.RobothABI;
	this. RobothAPI = web3.eth.contract(this.RobothABI);
	this. Roboth = this.RobothAPI.at(this.Registrar.addr('Roboth'));

	// singleton
	window.Roboth = this.Roboth;
	window.eth = web3.eth;

	this.reg_cache = new RegistrarCache(this, true);
	this.blockchain_tracker = new BlockchainUpdateTracker();
	this.userdata_mgr = new UserDataManager(this);

}

RoEthCls.instance = function() {
	if (window._roeth_inst == null) {
		window._roeth_inst = new window.RoEthCls();
	}
	return window._roeth_inst;
}

/**  For results of contract calls */
RoEthCls.isNull = function(res) {
	if ((res == '') || (res == null) || (res == undefined)) return true;
	if (_.isString(res) && res.codePointAt(0) == 0) return true;
	if (new BigNumber(res).equals(0)) return true;
	return false;
}

// some convenience global vars
window.RoEthCls = RoEthCls;
window.RoInst = RoEthCls.instance;

/**
Currently the primary data structure in the contract is UserData which is a mapping of each
user's jobs and proposed solutions to other jobs.
This class takes care of updating that data structure from the blockchain and providing it
to the templates in a reactive way.

@class UserDataManager
*/

UserDataManager = function(RoEth) {
	this.react_var = new ReactiveVar();
	this.dirty = true;
	this.ro_eth = RoEth;

	// auto-loads
	this.enableAutoUpdater();
}

/**  Subscribe to updates from blockchain_tracker using a Meteor autorun. */
UserDataManager.prototype.enableAutoUpdater = function() {
	var self = this;
	Deps.autorun(function() {
		//console.log('UserDataManager autoran');
		self.autoUpdater();
	});

}

/**  Indicate that GUI should be refreshed next time there's a new block */
UserDataManager.prototype.setDirty = function() {
	this.dirty = true;
}

UserDataManager.prototype.autoUpdater = function() {
	this.ro_eth.blockchain_tracker.block_number.get();

	if (this.dirty) {
		this.update();
	}
}

/**  For use in template helpers */
UserDataManager.prototype.get = function() {
	return this.react_var.get();
}

UserDataManager.prototype.update = function() {
	var xUserData = {};

	for (var i = 0; i < Roboth.m_next_userid().toFixed(); i++) {
		var user = Roboth.m_userdata_idx(i)
		var usrdat = Roboth.m_userdata(user);

		var mem_user_obj = {
			jobs: [],
			solutions: []
		};

		// fetch dictjobs
		for (var dji = 0; dji < usrdat[0].toFixed(); dji ++) {
			var res = Roboth.getDictJob(user, dji);
			var job = {
				word: web3.toAscii(res[0]),
				reward: res[1].toString(),
				owner: user,
				idx: dji
			};
			mem_user_obj.jobs.push(job);
		}

		xUserData[user] = mem_user_obj;
	}

	for (var i = 0; i < Roboth.m_next_userid().toFixed(); i++) {
		var user = Roboth.m_userdata_idx(i)
		var usrdat = Roboth.m_userdata(user);
		var sol_ids = [];

		// fetch solutions
		for (var si = 0; si < usrdat[1].toFixed(); si ++) {
			var res = Roboth.getSolution(user, si);
			var sol = {
				author: res[0],
				job_idx: res[1],
				idx: si,

				desc: web3.toAscii(res[2]),
				votes: res[3]
			};

			xUserData[user].solutions.push(sol);
		}
	}

	// update UI
	this.dirty = false;
	this.react_var.set(xUserData);
	console.log('updated to', xUserData);
}

/* idea
function SolidityIdIterator(inst, max_fn, item_fn) {
	this.inst = inst;
	this.max_fn = max_fn;
	this.item_fn = item_fn;

}
*/



/**
ReactiveVar wrapper that updates when there is a new block. Polls once every 6s

@class BlockchainUpdateTracker
*/

BlockchainUpdateTracker = function() {
	this.last_block = web3.eth.blockNumber;
	var self = this;
	this.interval_id = setInterval(function() { self.onTick(); }, 6000);
	this.block_number = ReactiveVar()
}

BlockchainUpdateTracker.prototype.onTick = function() {
	var block = web3.eth.blockNumber;
	if (block == this.last_block) return;
	this.last_block = block;

	this.block_number.set(block);
	//console.log('Detected block number', block);
}


BlockchainUpdateTracker.prototype.stop = function() {
	clearInterval(this.interval_id);
	this.interval_id = null;
}


/**
  Memoization for registrar data

  @class RegistrarCache
  */
RegistrarCache = function(ro_eth, watch) {
	this.ro_eth = ro_eth;
	this.by_name = {};
	this.by_addr = {};
	this.watch = watch;
	this.filters = {};
}

RegistrarCache.prototype.readableAddr = function(addr) {
	return addr.substr(0, 4 + 2) + ' ' + addr.substr(2 + 4, 4) + '...';
}

RegistrarCache.prototype.regName = function(addr) {
	if (RoEthCls.isNull(addr)) return '0x00';

	if (! this.by_addr[addr]) {
		var fnd = this.ro_eth.Registrar.name(addr);

		if (! RoEthCls.isNull(fnd)) {
			this.by_addr[addr] = fnd;
			this.by_name[this.by_addr[addr]] = addr;

			if (this.watch) this.watchItem(this.by_addr[addr]);

			return fnd;
		} else {
			return this.readableAddr(addr);
		}
	}
	return this.by_addr[addr];
}

RegistrarCache.prototype.regAddr = function(name) {
	if (! this.by_name[name]) {
		var fnd = this.ro_eth.Registrar.addr(name);

		if (! RoEthCls.isNull(fnd)) {
			this.by_name[name] = fnd;
			this.by_addr[this.by_name[name]] = name;

			if (this.watch) this.watchItem(name);
			return fnd;

		} else {
			return null;
		}
	}

	return this.by_name[name];
}

RegistrarCache.prototype.watchItem = function(name) {
	var self = this;
	var filter = this.ro_eth.Registrar.Changed(name);
	filter.watch(function(err, res) {
		if (!err) {
			var addr = self.by_name[res.args.name];
			delete self.by_name[res.args.name];
			delete self.by_addr[addr];
		}
	});
	this.filters[name] = filter;
}
